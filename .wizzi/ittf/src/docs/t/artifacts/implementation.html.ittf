$group
    $
        var sect = {
            title: 'Implementation'
        };

    section(&sect)


		p An artifact generator produces a buffer of text characters.
            \b The production is driven by models contained in the
			\b parameters passed to the generator.

		p An artifact generator receives three parameters:
		ittf-panel
            ittf
                func gen
                    { model
                        | api-ref wizzi-plugin.wizziModel
                        | POJO
                    { ctx
                        api-ref wizzi.artifact.genContext
                    callback
		ul
			li A model, a javascript object, that can be a Wizzi Model or a POJO, 
				\b and represent the main object context of the artifact generation,
				\b the model that drives the generation.
			li An instance of the wizzi.artifact.genContext class that contains
				ul
					li An in-memory buffer where the generated text is written
						\b sequentially using write and write line methods.
					li A data context that may contain zero or many secondary
						\b context models, Wizzi Models or POJO.
					li Some helper functions for text indentation, interpolation
						\b and error management.
			li A callback function that a succesfull generation must call
				\b passing, as a second parameter, an instance of the 
				\b wizzi.artifact.genContext with the text buffer containing
				\b the generated artifact

		p An artifact generation can be code write based, using the write statements
			\b of the wizzi.artifact.genContext instance, or template based.
			\b The wizzi factory uses both systems with a preference, when convenient,
			\b for the template based one, and uses the mTree loader as its preferred
			\b template engine.

		h3 Code generation by term rewriting
		
		p The mTree loader, implemented by the wizzi-mtree.loader.loadMTree API method, is
			\b a powerfull model composer and transformer. 
			\b Model transformations can be 
			\b chained: an output mTree can become the input context for the next
			\b mTree loading. A 'wfjob' model can orchestrate any number of cascading
			\b transformations.
			\b The models passed to the artifact generator are the final
			\b models, ripe and ready for generating the textual artifact.
		
		p A template based generation, that uses the mTree loader,
			\b can be, indeed, more a code generation by term rewriting
			\b than a textual code generation. When mTrees are loaded into Wizzi Models,
			\b that can apply types and validations, and can programmatically modify the model,
			\b we have a tool for efficiently enabling any extension of the target
			\b language, easily implementing partial classes or any other modular
			\b aspect or rewrite rule.

		h3 Language schemas and language artifact generators
		p Focusing on the generation of 
			\b the textual content of an artifact, we must treat of a class
			\b of Wizzi Model types that is specific for the production
			\b of code targeting the synthax of a programming languages (PL).

		p A language schema defines a tree structure
			\b that an associated language artifact generator can transform
			\b in a targeting PL code. It can be viewd as a profile of a PL Grammar that 
			\b can be implemented partially,
			\b with some of its symbols stereotyped. The schema developer should try 
			\b to find the optimal balance between ease of use and completeness and
			\b define the proper approximation of the schema in respect to the PL grammar.

		p Must be said that language schema is a concept. A language schema is
			\b like any other wizzi schema and a language artifact is
			\b like any other artifact generator. The production of specific tools for
			\b creating language schemas and artifacts could be 
			\b undertaken in the future.

		p The wizzi factory, that is generated by the wizzi factory,
			\b uses some language schemas for its generations:
		ul
			li The js schema in the wizzi-js plugin.
			li The html and css schemas in the wizzi-html plugin.
			li The md (markdown) schema in the wizzi-docs plugin.

		h3 Template based artifact generation

		p Wizzi models which type is a language schema are the ideal template
			\b format for a wizzi factory template based artifact generation.

		h4 This is an example of a js ittf document
        ittf-panel
            ittf
                module
                    kind jsfile
                    class Horse
                        super Animal
                        ctor
                            param name
                            base name
                        m say
                            log 'Hiiii i am ' \b this.name
                        m create
                            static
                            param name
                            return
                                new Horse
                                    @ name

		p Almost every ittf node maps to a node type of the javascripts AST. And 
			\b ittf nodes can be template node commands and can contain expressions.

		h4 Example of template based implementation of
			\b the wizzi-plugin.artifactGenerator API
		p In this dummy example, a 'js' ittf document template,
			\b named 'datalayer/adapters.js.ittf'
			\b is transformed in the javascript textual code of a fictitious datalayer
			\b adapter component.
		p This example artifact generator makes use internaly of a 'js' language
			\b artifact generator, named 'js/module'. The model that it receives as 
			\b the first parameter, that has been loaded in previous steps, becomes 
			\b the mTreeBuilUpContext object for loading the mTree of the template. 
			\b It must be a Wizzi Model of type 'rdbms' otherwise an error
			\b is returned in the callback.
		p The template is loaded, and transformed in a textual artifact, calling
			\b the 'loadModelAndGenerateArtifact' method of the current instance of
			\b the wizzi.wizziFactory class, exposed in the property 'wizziFactory'
			\b of the 'ctx' parameter (an instance of the wizzi.artifact.genContext class).
		ittf-panel
            ittf
                module
                    kind jsfile
                    var path = require('path')
                    var md = module.exports = {}
                    var myname = 'artifact rdbms.adapters.main';
                    set md.gen
                        function
                            { model
                            { ctx
                            callback
                            # check the model is a Wizzi Model of type 'rdbms'
                            if model.wzElement !== 'rdbms'
                                return
                                    callback
                                        _ctx.error
                                            @ myname + " error: the model paramater should be an 'rdbms' Wizzi Model"
                                            @ model
                            # build the artifact template path, it is a js ittf document in a sub folder
                            var ittfTemplatePath
                                _ path.join
                                    @ __dirname
                                    @ 'ittf'
                                    @ 'datalayer'
                                    @ 'adapters.js.ittf'
                            # call the wizzifactory method for loading a language Wizzi Model and
                            # generate a language artifact from it. Pass the input model in the
                            # mTreeBuildUpContext property of the request object argument.
                            # The 'js' schema of the template model is detected by its filename.
                            _ ctx.wizziFactory.loadModelAndGenerateArtifact
                                @ ittfTemplatePath
                                {
                                    @ mTreeBuildUpContext model
                                @ 'js/module'
                                function
                                    param err
                                    param artifactText
                                    if err
                                        # invoke the callback on error, passing back the loadModelAndGenerateArtifact error
                                        return
                                            _ callback
                                                err
                                    # write the artifactText into the genContext buffer
                                    _ ctx.write(artifactText)
                                    # invoke the callback on success, passing back the genContext
                                    _ callback(null, ctx)
		


