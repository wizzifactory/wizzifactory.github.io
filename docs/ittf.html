<!doctype html>
<html VERSION-5="5" VERSION-4="4" version="5">
<head>
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" />
    <link href="sanitize.css" rel="stylesheet" />
    <link href="../styles/main.css" rel="stylesheet" />
    <link href="../styles/documentation-ittf.css" rel="stylesheet" />
</head>
<body class="Documentation-ittf">
    <!-- top navigation markup -->
    <input type="checkbox" id="tn-input-toggle" />
    <nav class="tn-bar">
        <nav class="tn-main">
            <a href="index.html.ittf"><div class="logo">
                <img src="../images/logo.svg" />
            </div>
            </a>
            <label for="tn-input-toggle" class="tn-label-toggle"></label>
            <label for="tn-input-toggle" class="tn-label-toggle-close">&times;</label>
            <ul>
                <li><a href="../concepts.html">Concepts</a>
                </li>
                <li class="tn-pageSelected"><a href="../docs/intro.html">Documentation</a>
                <nav class="tn-subPages_mobile">
                    <ul>
                        <li><a href="../docs/intro.html">intro</a>
                        </li>
                        <li><a href="../docs/ittf.html">ittf</a>
                        </li>
                        <li><a href="../docs/jswizzi.html">jswizzi</a>
                        </li>
                        <li><a href="../docs/models.html">models</a>
                        </li>
                        <li><a href="../docs/artifacts.html">artifacts</a>
                        </li>
                        <li><a href="../docs/jobs.html">jobs</a>
                        </li>
                        <li><a href="../docs/plugins.html">plugins</a>
                        </li>
                    </ul>
                </nav>
                </li>
                <li><a href="../api.html">Api</a>
                </li>
                <li><a href="../code/intro.html">Code</a>
                </li>
                <li><a href="../starters.html">Starters</a>
                </li>
                <li><a href="../project.html">Project</a>
                </li>
            </ul>
        </nav>
        <nav class="tn-subPages">
            <ul>
                <li><a href="../docs/intro.html">intro</a>
                </li>
                <li class="tn-subPageSelected"><a href="../docs/ittf.html">ittf</a>
                </li>
                <li><a href="../docs/jswizzi.html">jswizzi</a>
                </li>
                <li><a href="../docs/models.html">models</a>
                </li>
                <li><a href="../docs/artifacts.html">artifacts</a>
                </li>
                <li><a href="../docs/jobs.html">jobs</a>
                </li>
                <li><a href="../docs/plugins.html">plugins</a>
                </li>
            </ul>
        </nav>
    </nav>
    <!-- main content markup -->
    <main id="mc-wrapper" class="mc-wrapper-layout-sub">
        <input type="checkbox" id="mc-toggle-toc" />
        <input type="checkbox" id="mc-toggle-toc-close" onchange="mc_toggle_toc_Close()" />
        <div class="mc-frame">
            <div class="mc-frame-bar">
                <h1 class="mc-sidebar-left-title">ittf</h1>
                <h1>
                    <label for="mc-toggle-toc-close" class="mc-label-toggle-close">&times;</label>
                </h1>
            </div>
            <nav class="mc-sidebar-left">
                <ul>
                    <li><a href="#concept-intro" class="mc-item-link">Introduction</a>
                    <label for="mc-toggle-concept-intro" class="mc-label-toggle">Introduction</label>
                    </li>
                    <li><a href="#concept-1" class="mc-item-link">Ittf document</a>
                    <label for="mc-toggle-concept-1" class="mc-label-toggle">&nbsp; Ittf document</label>
                    </li>
                    <li><a href="#concept-2" class="mc-item-link">Ittf notation</a>
                    <label for="mc-toggle-concept-2" class="mc-label-toggle">&nbsp; Ittf notation</label>
                    </li>
                    <li><a href="#concept-3" class="mc-item-link">Xml documents comparision</a>
                    <label for="mc-toggle-concept-3" class="mc-label-toggle">&nbsp; Xml documents comparision</label>
                    </li>
                    <li><a href="#concept-4" class="mc-item-link">Ittf documents composition</a>
                    <label for="mc-toggle-concept-4" class="mc-label-toggle">&nbsp; Ittf documents composition</label>
                    </li>
                    <li><a href="#concept-5" class="mc-item-link">Ittf templates</a>
                    <label for="mc-toggle-concept-5" class="mc-label-toggle">&nbsp; Ittf templates</label>
                    </li>
                    <li><a href="#concept-6" class="mc-item-link">Ittf documents as code units</a>
                    <label for="mc-toggle-concept-6" class="mc-label-toggle">&nbsp; Ittf documents as code units</label>
                    </li>
                    <li><a href="#concept-7" class="mc-item-link">Ittf node commands</a>
                    <label for="mc-toggle-concept-7" class="mc-label-toggle">&nbsp; Ittf node commands</label>
                    </li>
                    <li><a href="#concept-8" class="mc-item-link">Path resolution of composed documents</a>
                    <label for="mc-toggle-concept-8" class="mc-label-toggle">&nbsp; Path resolution of composed documents</label>
                    </li>
                </ul>
            </nav>
            <div class="mc-content">
                <div>
                    <input type="checkbox" id="mc-toggle-concept-intro" onchange="m_toggleChanged()" />
                    <input type="checkbox" id="mc-toggle-concept-1" onchange="m_toggleChanged()" />
                    <input type="checkbox" id="mc-toggle-concept-2" onchange="m_toggleChanged()" />
                    <input type="checkbox" id="mc-toggle-concept-3" onchange="m_toggleChanged()" />
                    <input type="checkbox" id="mc-toggle-concept-4" onchange="m_toggleChanged()" />
                    <input type="checkbox" id="mc-toggle-concept-5" onchange="m_toggleChanged()" />
                    <input type="checkbox" id="mc-toggle-concept-6" onchange="m_toggleChanged()" />
                    <input type="checkbox" id="mc-toggle-concept-7" onchange="m_toggleChanged()" />
                    <input type="checkbox" id="mc-toggle-concept-8" onchange="m_toggleChanged()" />
                    <h1 class="mc-content-title" id="concept-intro">ittf</h1>
                    <div class="mc-pane mc-pane-concept-intro">
                        <div class="summary"></div>
                    </div>
                    <div class="mc-pane mc-pane-concept-1">
                        <h2 id="concept-1">Ittf document</h2>
                        <div class="summary">
                            <p>Ittf, Indented Text Tree Format, is a document type for declaring and transferring a textual representation of a tree structure of name-valued nodes.</p><p>Ittf documents are building blocks, made to be loaded and composed into a javascript tree structure, named mTree.</p><p>A single ittf document, when loaded, becomes an mTreeBrick, a composition element that can include or mix other mTreeBricks and can in turn be included or mixed.</p><p>Ittf documents also can be templates or pieces of templates. They can contain conditional or repeat template node commands and can use context objects, passed to the mTree load function, for creating new nodes of the composed mTree.</p><p>Further ittf documents can be code units, and can codify statements and expressions using a sandboxed subset of the ECMA-262 javascript standard named 'jswizzi'. Statements can create, and modify, variables (in the evaluation context of an mTreeBrick or in the global evaluation context) that template node commands can use to select or create nodes.</p><p>We will see next:    <ul>        <li>The ittf notation        </li><li>Ittf documents composition        </li><li>Ittf template node commands        </li><li>Ittf documents as code units        </li>    </ul></p></div>
                    </div>
                    <div class="mc-pane mc-pane-concept-2">
                        <h2 id="concept-2">Ittf notation</h2>
                        <div class="summary">
                            <p>Documents are made of 'phisical' text lines separated by a:    <ul>        <li>x'000a' char or</li><li>x'000d' char or        </li><li>x'000a' + x'000d' couple of chars        </li>    </ul></p><p>A line is made of a node-name and a node-value separated by a white-char (space or tab).</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">name</span><span class="pp-pln"> value</span></li><li class="L2"><span class="pnl">  </span><span class="pp-tag">name</span><span class="pp-pln"> value</span></li></ol></pre><p>Node-values always are trimmed, you cannot have a node-value that starts or ends with a white-char sequence.</p><p>Example. When loaded, both these nodes will containg the 'value' string in the node-value.</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">name1</span><span class="pp-pln"> value</span></li><li class="L2"><span class="pnl">  </span><span class="pp-tag">name2</span><span class="pp-pln"> value</span></li></ol></pre><p>The node hierarchy is built calculating the indentation of node-names in a text line. Every tab or every 4 space chars preeceding a node-name count for one level of indentation.</p><p>The node-name of the first line (the root node-name) must have indentation zero. The node-name must start at column 1 (1-based) of the first row.</p><p>An ittf document cannot have more than one root node. If the semantic of a document require more than one root node one can use the convenience '$group' node command. It may be used as the root node of a composed document (included or mixed) and is ignored during the mTree build up so its children logically become root nodes of the document.</p><p>Example. Ittf document with two root nodes.</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-kwd">$group</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-tag">root1</span><span class="pp-pln"> value1</span></li><li class="L3"><span class="pnl">  </span><span class="pp-tag">root2</span><span class="pp-pln"> value2</span></li></ol></pre><p>A line become a node which parent is the first preceeding line with a lesser indentation.</p><p>Phisical text lines may have line continuatios and a 'logical' line may contain many phisical lines. There are three pre-defined node-names that allow line continuation:    <ul>        <li>'\' means that the node-value is joined to the node-value of the parent node without separation.        </li><li>'\b' means that the node-value is joined to the node-value of the parent node with one space char separator.        </li><li>'\n' means that the node-value is joined to the node-value of the parent node with one Line Feed char separator.        </li>    </ul></p><p>Example of line continuation. Both 'name1'  and 'name2' have the same value.</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">root</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-tag">name1</span><span class="pp-pln"> I am</span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag">\b</span><span class="pp-pln"> a single</span></li><li class="L4"><span class="pnl">    </span><span class="pp-tag">\b</span><span class="pp-pln"> line</span></li><li class="L5"><span class="pnl">  </span><span class="pp-tag">name2</span><span class="pp-pln"> I am a single line</span></li></ol></pre><p>Node names and values are text strings by design, and never require quotes (they are unquoted by the lexer). The wizzi factory is a text manipulator. If the semantic of a node-value require that it is treated as a different type (boolean, integer, float or date), that can be done using wizzi schemas, that apply types to the tree structure resulting from loading an ittf document (see mTrees).</p><p>One exception to this rule is when an argument is passed to a mixed ittf document, and will become part of its evaluation context. Types different from string can be usefull in jswizzi statements and expessions. The '$params' node command, that declares the parameters received by a mixed ittf document, may assign a type to passed arguments.</p><p>In any case the lexer do not detect types. When needed they must be declared.</p></div>
                    </div>
                    <div class="mc-pane mc-pane-concept-3">
                        <h2 id="concept-3">Xml documents comparision</h2>
                        <div class="summary">
                            <h4>Content model</h4><p>XML differentiates two types: elements containing only element content (no character data) and mixed content (elements that may contain character data optionally interspersed with child elements).</p><p>Ittf documents have no mixed content. They have ittf nodes only. They do not have the concept of element or attribute or text.</p><p>Only the application of a wizzi schema to an mTree, loading a wizzi model, can trasform an ittf node in an element or attribute or text, depending on the schema specification.</p><h4>Document types and document type definitions</h4><p>A wizzi schema is actually a documemnt type definition, but it applies to loaded mTrees not to ittf documents. Ittf documents creators must design their documents to obtain a valid mTree after composition and evaluation, just before loading it in a wizzi model.</p><p>An ittf document, when created for composing an mTree for a specific wizzi schema, can be considered to have the type of that wizzi schema. The type of an ittf document must be recognizable from its name, that must end with '.`schema`.ittf'. Example of ittf document of type 'js': 'index.js.ittf'.</p><h4>Markup declaration and markup model</h4><p>In XML a markup declaration is a syntactical construct within a DTD declaring an entity or defining a markup structure.</p><p>Wizzi schemas do not need to declare entities, because ittf document can contain expressions and template commands. But, like DTDs, they declare elements and attributes structure, and like DTDs the define a model (wizzi model) of an mTree content.</p><p>In the wizzi factory, wizzi models are not just a concept, but also a concrete javascript module, generated from a wizzi schema declaration, that can load valid mTrees, and may be used as a context object by: the mTree loader, model transformers and artifact generators.</p><h4>Elements and element types</h4><p>Wizzi schema elements and XML DTD element types have the same goal. Wizzi model elements are such only after the mTree loading of an ittf document. In ittf documents we have potential model elemnts.</p><h4>Valid characters</h4><p>Ittf documents accept any character. The wizzi factory ignores the content of documents and has no concept of data type. Are wizzi schemas that can constrain node names and values.</p><p>When generating the javascript module that implements wizzi model types the names of classes and attributes are checked and invalid chars for javascript names are replaced with the '_' char. Class names colliding with javascript keywords are prefixed with the letter 'x'.</p></div>
                    </div>
                    <div class="mc-pane mc-pane-concept-4">
                        <h2 id="concept-4">Ittf documents composition</h2>
                        <div class="summary">
                            <p>An ittf document, when loaded, become a javascript object named mTreeBrick.</p><p>mTreeBricks are composition units. They can mix, or include, other bricks and can be mixed, or included. The mix or include operation is declared on a node of the mixer or includer brick, that will be replaced from the nodes of the mixed or included one.</p><p>An mTree loading begins loading a primary ittf document, that become the primary mTreeBrick, the starting point of the composition. Included and mixed ittf documents are named composed ittf documents that become composed mTreeBricks.</p><p>A single mTreeBrick can be composed many times in different positions of the builded mTree. It is loaded once, and cloned for composition.</p><p>Include and mix operations have a different behaviour. When included, cloned mTreeBricks, become part of the includer brick and their nodes acquire its brick key and its brick evaluation context. Instead, mixed mTreeBricks, are inserted in the node structure of the mixer, but each of them mantains its original brick key and brick evaluation context. When coding an ittf document, that will become a mixed mTreeBrick, created variables will have a scope limited to the nodes declared in the document, even if they will be merged in the mixer brick.</p><p>Summarizing: primary and mixed mTreeBricks have their own evaluation context, included mTreeBricks use the evaluation context of their includer.</p><p>In case of a mixed mTreeBrick the mixer node can have children nodes that in turn can replace 'hook' nodes of the mixed brick. See the '$hook' and '$append' ittf command nodes for the composition rules of a mix operation.</p></div>
                    </div>
                    <div class="mc-pane mc-pane-concept-5">
                        <h2 id="concept-5">Ittf templates</h2>
                        <div class="summary">
                            <p>mTreeBricks are composable templates, and their nodes can contain template node commands and jswizzi expressions, that will be processed in the final step of the mTree loading: the evaluation step.</p><p>The buildup of the resulting mTree can create new nodes using repeat node commands like '$foreach' and '$while' and can include or exclude node branches using '$if', '$elif' and '$else' conditional node commands.</p><p>jswizzi statements and expression are executed in the mTreeBrick evaluation context and may access global context variables.</p><h3>$foreach repeat node command</h3><p>Format</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$foreach</span><span class="pp-pln"> item-name in collection-name</span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag">...</span><span class="pp-pln"> node branch ...</span></li></ol></pre><p>Descendant nodes of this node command are a repeat template; item-name is user defined and collection-name is a jswizzi expression that evaluates to an iterable javascript object, in scope in the mTreeBrick or in the global jsWizziContext.</p><p>The var statement that declares item-name is auto-generated.</p><p>Descendant nodes are repeated having item-name as a value in scope.</p><h3>$while repeat node command</h3><p>This is a repeat template statement where descendant nodes are repeated until the jswizzi-expression evaluates to false.</p><p>$ or $global node commands must be used to modify the context values of the exit condition. There is a limit of 10000 iterations to guard against accidental loops, after that an exception is raised.</p><p>TODO make the limit of 10000 iterations configurable and an optional parameter of the loadMTree function.</p><p>Format:</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$while</span><span class="pp-pln"> jswizzi-expression</span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag">...</span><span class="pp-pln"> node branch ...</span></li><li class="L4"><span class="pnl">    </span><span class="pp-kwd">$</span><span class="pp-expr"> jswizzi-exit-condition-change</span></li></ol></pre><h3>$break, $continue repeat node commands</h3><p>This statements have the same meaning than in javascript but operate breaking or continuing the template repetition.</p><p>A label for continuation is not implemented.</p><p>Format:</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$foreach</span><span class="pp-pln"> ... | $while ...</span></li><li class="L3"><span class="pnl">    </span><span class="pp-kwd">$break</span><span class="pp-pln"> empty-value</span></li><li class="L4"><span class="pnl">    </span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L5"><span class="pnl">    </span><span class="pp-kwd">$continue</span><span class="pp-pln"> empty-value</span></li></ol></pre></div>
                    </div>
                    <div class="mc-pane mc-pane-concept-6">
                        <h2 id="concept-6">Ittf documents as code units</h2>
                        <div class="summary">
                            <p>We have seen that primary and mixed mTreeBricks have their own evaluation context. An mTree loading also has a global evaluation context, where are loaded javascript components that jswizzi can safely access and the context objects passed to the wizzi-mtree.loader.loadMTree function.</p><p>Template node commands and expressions contained in node names and node values can access the global context and the evaluation context of their mTreeBrick.</p><p>With code node commands we can declare statements that modify or create variables in both the evaluation contexts.</p><h3>The '$' code node command</h3><p>Can be used to declare single line or multi-line jswizzi-statements, that during the evaluation step, are executed in the mTreeBrick scope to which the node command belongs.</p><p>They may declare and modify variables that have mTreeBrick scope, and modify variables that have global scope.</p><h4>Single line format</h4><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$</span><span class="pp-expr"> jswizzi-statement</span></li></ol></pre><h4>Example</h4><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$</span><span class="pp-expr"> var names = ['stefi', 'annie'];</span></li></ol></pre><h4>Multi-line format</h4><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-kwd">$</span><span class="pp-expr"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-expr">jswizzi-statement</span><span class="pp-expr"> </span></li><li class="L3"><span class="pnl">  </span><span class="pp-expr">jswizzi-statement</span><span class="pp-expr"> </span></li><li class="L4"><span class="pnl">  </span><span class="pp-expr">...</span><span class="pp-expr"> </span></li></ol></pre><h4>Example</h4><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$</span><span class="pp-expr"> </span></li><li class="L3"><span class="pnl">    </span><span class="pp-expr">var</span><span class="pp-expr"> names = ['stefi', 'annie'];</span></li><li class="L4"><span class="pnl">    </span><span class="pp-expr">var</span><span class="pp-expr"> j = 0;</span></li></ol></pre><h3>The $global code node command</h3><p>Can be used to declare single line or multi-line jswizzi-statements, that during the evaluation step, are executed in the global scope.</p><p>They may modify variables that have mTreeBrick scope, and create and modify variables that have global scope.</p><h4>Single line format</h4><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$global</span><span class="pp-pln"> jswizzi-statement</span></li></ol></pre><h4>Multi-line format</h4><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-kwd">$global</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-expr">jswizzi-statement</span><span class="pp-expr"> </span></li><li class="L3"><span class="pnl">  </span><span class="pp-expr">jswizzi-statement</span><span class="pp-expr"> </span></li><li class="L4"><span class="pnl">  </span><span class="pp-expr">...</span><span class="pp-expr"> </span></li></ol></pre></div>
                    </div>
                    <div class="mc-pane mc-pane-concept-7">
                        <h2 id="concept-7">Ittf node commands</h2>
                        <div class="summary">
                            <h3>$include</h3><p>Format:</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$include</span><span class="pp-pln"> include-path</span></li></ol></pre><p>The node value (include-path) is the relative path to the ittf document that must be included. The folder uri of the includer document is the base path for the path resolution of composed documents.</p><p>The included mTreeBrick will be included as is, replacing the $include node command, and its nodes will become part of the scope of the includer.</p><p>An $include node command cannot have children nodes. The included mTreeBrick cannot have brick composition parameters.</p><h3>Mixin inclusion (alias mixer node)</h3><p>Format:</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-mix">mixin-path(</span><span class="pp-pln"> arg-1 [, arg-2 ... [, arg-n]] )</span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag">[</span><span class="pp-pln"> optional ittf node branch ]</span></li></ol></pre><p>A mixin inclusion is recognized by the line parser when a node name ends with an open parenthesis. The chars before the open parenthesis are the relative path to the mixed ittf document. The folder uri of the mixer ittf document is the base path. No whitechar must separate the mixin path and the open paren.</p><p>The mixed mTreeBrick is inserted in the mixer one replacing the mixin inclusion node command. If the mixer node has children they, by default, are appended to the root node of the mixed mTreeBrick. But if the mixed brick has a descendant node that is a '$hook' node command of name 'default', than the children of the mixer node will replace it.</p><p>Example of mixin with an $hook node command where children of the mixer node will be appended. The hook-name is not declared, so it is assumed to be 'default').</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">table</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$hook</span><span class="pp-pln"> </span></li></ol></pre><p>The root node of a mixed ittf document can be a mixin inclusion node command:</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-mix">mylayout(</span><span class="pp-pln"> home )</span></li><li class="L2"><span class="pnl">  </span><span class="pp-tag">div</span><span class="pp-pln"> My content</span></li></ol></pre><h3>$params</h3><p>Format:</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">rootnode</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$params</span><span class="pp-pln"> param1 [,param2 [,param-n]]</span></li></ol></pre><table><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">li</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$params</span><span class="pp-pln"> text, href</span></li><li class="L3"><span class="pnl">  </span><span class="pp-tag">a</span><span class="pp-pln"> ${text}</span></li><li class="L4"><span class="pnl">    </span><span class="pp-tag">href</span><span class="pp-pln"> ${href}</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$hook</span><span class="pp-pln"> name</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$append</span><span class="pp-pln"> hook-name</span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag">...</span><span class="pp-pln"> node branch ...</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-kwd">$group</span><span class="pp-pln"> empty-value</span></li><li class="L2"><span class="pnl">  </span><span class="pp-tag">...</span><span class="pp-pln"> node branch ...</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$if</span><span class="pp-expr"> jswizzi-expression</span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag">...</span><span class="pp-pln"> node branch ...</span></li><li class="L4"><span class="pnl">  </span><span class="pp-kwd">$elif</span><span class="pp-expr"> jswizzi-expression</span></li><li class="L5"><span class="pnl">    </span><span class="pp-tag">...</span><span class="pp-pln"> node branch ...</span></li><li class="L6"><span class="pnl">  </span><span class="pp-kwd">$else</span><span class="pp-pln"> empty-value</span></li><li class="L7"><span class="pnl">    </span><span class="pp-tag">...</span><span class="pp-pln"> node branch ...</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$foreach</span><span class="pp-pln"> item-name in collection-name</span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag">...</span><span class="pp-pln"> node branch ...</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$break</span><span class="pp-pln"> empty-value</span></li><li class="L3"><span class="pnl">  </span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L4"><span class="pnl">  </span><span class="pp-kwd">$continue</span><span class="pp-pln"> empty-value</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$while</span><span class="pp-pln"> jswizzi-expression</span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag">...</span><span class="pp-pln"> node branch ...</span></li><li class="L4"><span class="pnl">    </span><span class="pp-kwd">$</span><span class="pp-expr"> jswizzi-exit-condition-change</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$</span><span class="pp-expr"> jswizzi-statement</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-kwd">$</span><span class="pp-expr"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-expr">jswizzi-statement</span><span class="pp-expr"> </span></li><li class="L3"><span class="pnl">  </span><span class="pp-expr">jswizzi-statement</span><span class="pp-expr"> </span></li><li class="L4"><span class="pnl">  </span><span class="pp-expr">...</span><span class="pp-expr"> </span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$global</span><span class="pp-pln"> jswizzi-statement</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-kwd">$global</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-expr">jswizzi-statement</span><span class="pp-expr"> </span></li><li class="L3"><span class="pnl">  </span><span class="pp-expr">jswizzi-statement</span><span class="pp-expr"> </span></li><li class="L4"><span class="pnl">  </span><span class="pp-expr">...</span><span class="pp-expr"> </span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$.</span><span class="pp-pln"> </span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag">free</span><span class="pp-pln"> content</span></li><li class="L4"><span class="pnl">    </span><span class="pp-tag">free</span><span class="pp-pln"> content</span></li><li class="L5"><span class="pnl">    </span><span class="pp-tag">...</span><span class="pp-pln"> </span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-tag">ul</span><span class="pp-pln"> </span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag"></span><span class="pp-pln"> </span></li><li class="L4"><span class="pnl">    </span><span class="pp-tag">li</span><span class="pp-pln"> item</span></li></ol></pre><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">...</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-tag"></span><span class="pp-pln"> </span></li></ol></pre>    <tr>        <td>param        </td><td> [&]name[:type][|default]        </td>    </tr><tr>        <td>&        </td><td> the paramater is an object passed by reference        </td>    </tr><tr>        <td>name        </td><td> the name of the parameter to be used in IttfMacro expressions        </td>    </tr><tr>        <td>type        </td><td> the parameter type            <p>one-of: string(default), integer, float, boolean, date, object (implicit when '&' declared), macro (implicit, detected from IttfMacro delimiters contained in the default value)            </p>        </td>    </tr><tr>        <td>default        </td><td> typed-value | @@null | @@undefined            <p>warning! `title|null` becomes title = "null" (the quoted string null)            </p><br> if you want title to be null then : `title|@@null`            </br>        </td><tr>            <td>string            </td><td> quotes are optional            </td>        </tr><tr>            <td>boolean            </td><td> true | false            </td>        </tr><tr>            <td>date            </td><td> yyyy/mm/dd            </td>        </tr><tr>            <td>macro            </td><td>                 <p>an IttfMacro can be passed as a parameter to a mixin, when the parameter is referenced we have a double macro substitution                </p>            </td>        </tr>    </tr><p>Example:    </p><h3>$hook    </h3><p>Format    </p><p>An $hook node command is a named insertion point where node branches can be appended. The name is optional, when missing its value is 'default'.    </p><p>It has to be replaced and must not have children nodes.    </p><p>See the statements MixinCall and AppendHookCall, for how to append IttfNodeBranches to an $hook node.    </p><h3>$append    </h3><p>Format    </p><p>An $append node command is the root of a node branch that should be appended to an ancestor $hook of name hook-name. The $append children nodes replace the $hook node.    </p><h3>$group    </h3><p>Format    </p><p>An ittf document must have one and only one root node.    </p><p>The $group node command is a convenience node that may be used, as the root of an included or mixed mTreeBrick, that must have more than one root node.    </p><p>The $group node disappear in the builded mTree.    </p><h3>$if, $elif, $else    </h3><p>Children nodes of these node commands are included/excluded from the builded mTree depending on the value of the expression.    </p><p>Format:    </p><h3>$foreach    </h3><p>Format:    </p><p>Descendant nodes of this node command are a repeat template; item-name is user defined and collection-name is a jswizzi expression that evaluates to an iterable javascript object, in scope in the mTreeBrick or in the global jsWizziContext.    </p><p>The var statement that declares item-name is auto-generated.    </p><p>Descendant nodes are repeated having item-name as a value in scope.    </p><h3>$break, $continue    </h3><p>Format:    </p><p>This statements have the same meaning than in javascript but operate breaking or continuing the template repetition.    </p><p>A label for continuation is not implemented.    </p><h3>$while    </h3><p>Format:    </p><p>This is a repeat template statement where descendant nodes are repeated until the jswizzi-expression evaluates to false.    </p><p>$ or $global node commands must be used to modify the context values of the exit condition. There is a limit of 10000 iterations to guard against accidental loops, after that an exception is raised.    </p><h3>$    </h3><p>Single line format:    </p><p>Multi-line format:    </p><p>Descendant nodes of this command can contain jswizzi statements that, during the evaluation step, are executed in the mTreeBrick scope to wich the node command belongs.    </p><p>They may declare and modify variables that have mTreeBrick scope, and modify variables that have global scope.    </p><h3>$global    </h3><p>Single line format:    </p><p>Multi-line format:    </p><p>Descendant nodes of this command can contain jswizzi statements that, during the evaluation step, are executed in the global scope of the jsWizziContext. They may declare or modify variables in the global scope.    </p><h3>$.    </h3><p>Format:    </p><h3>    </h3><p>Format:    </p><h3>    </h3><p>The multiline comment    </p><p>Format:    </p></table></div>
                    </div>
                    <div class="mc-pane mc-pane-concept-8">
                        <h2 id="concept-8">Path resolution of composed documents</h2>
                        <div class="summary">
                            <p>The path resolution algoritm for retrieving mixed and included ittf documents starts from the composer node. The folder uri, of the ittf document containing the composer node, gives the base path. The name of the composed document gives the relative path.</p><p>At first is searched the path resulting from joining base and relative path using the nodejs function path.resolve(...).</p><p>If this match fails, then the 't' folder rule is applied, starting from the base path and going down one step first, and then going up on the folder tree. The rule is the same followed by nodejs to locate packages. The wizzi factory uses folders named 't' as nodejs uses folders named 'node_modules'.</p><p>The search for a composed document proceeds as follow:</p><ul>    <li>search path.resolve(base-path, relative-path)    </li><li>search path.resolve(base-path, 't', relative-path)    </li><li>search path.resolve(path.dirname(base-path), 't', relative-path)    </li><li>search path.resolve(path.dirname(path.dirname(base-path)), 't', relative-path)    </li><li>...    </li></ul><p>until the document is found or the base-path of the wizzi factory repository, declared in the config file, is reached. In the last case the search fails and we have an IttfNotFound error.</p><p>Example. Given this folder structure</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-tag">folder-a</span><span class="pp-pln"> </span></li><li class="L2"><span class="pnl">  </span><span class="pp-tag">t</span><span class="pp-pln"> </span></li><li class="L3"><span class="pnl">    </span><span class="pp-tag">layouts</span><span class="pp-pln"> </span></li><li class="L4"><span class="pnl">      </span><span class="pp-tag">site-layout.html.ittf</span><span class="pp-pln"> </span></li><li class="L5"><span class="pnl">  </span><span class="pp-tag">folder-a1</span><span class="pp-pln"> </span></li><li class="L6"><span class="pnl">    </span><span class="pp-tag">t</span><span class="pp-pln"> </span></li><li class="L7"><span class="pnl">      </span><span class="pp-tag">dialog.html.ittf</span><span class="pp-pln"> </span></li><li class="L8"><span class="pnl">    </span><span class="pp-tag">my-home-page.html.ittf</span><span class="pp-pln"> </span></li></ol></pre><p>The ittf document my-home-page.html.ittf could contain these two composition node commands:</p><pre class="prettyprint"><ol class="linenums"><li class="L1"><span class="pnl"></span><span class="pp-mix">layouts/site-layout(</span><span class="pp-pln"> home )</span></li><li class="L2"><span class="pnl">  </span><span class="pp-kwd">$include</span><span class="pp-pln"> dialog( )</span></li></ol></pre><p>For both commands the base-path is 'folder-a/folder-a1'.</p><p>For the include node command the relative path is 'dialog.html.ittf' and the</p><p>document is found by: path.resolve(base-path, 't', relative-path).</p><p>For the mixin inclusion node command the relative path is 'layouts/site-layout' and the</p><p>document is found by: path.resolve(path.dirname(base-path), 't', relative-path).</p></div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    <script>
        /*
            artifact generator: C:\my\wizzi\v6\node_modules\wizzi-js\lib\artifacts\js\module\gen\main.js
            primary source IttfDocument: c:\my\wizzi\v6\test\wizzi-docs\jobs\ittf\docs\html\docs.html.ittf
            utc time: Fri, 28 Sep 2018 04:21:38 GMT
        */
        'use strict';
        function m_toggleChanged() {
            var el_toc = document.querySelector("input[id='mc-toggle-toc']");
            var el_contents = document.querySelectorAll("input[id^='mc-toggle-concept-']");
            var seenTrue = false;
            var i, i_items=el_contents, i_len=el_contents.length, el;
            for (i=0; i<i_len; i++) {
                el = el_contents[i];
                if (el.checked) {
                    seenTrue = true;
                }
            }
            el_toc.checked = seenTrue;
        }
        function mc_toggle_toc_Close() {
            var el_toc = document.querySelector("input[id='mc-toggle-toc']");
            var el_contents = document.querySelectorAll("input[id^='mc-toggle-concept-']");
            var i, i_items=el_contents, i_len=el_contents.length, el;
            for (i=0; i<i_len; i++) {
                el = el_contents[i];
                el.checked = false;
            }
            el_toc.checked = false;
        }
    </script>
</body>

</html>
